Absolument ! Voici un fichier `docker-compose.yml` professionnel et bien commenté pour un projet Go, incluant une configuration optimisée pour le développement.

Ce fichier suppose l'existence d'un `Dockerfile` principal pour la production et, idéalement, d'un `Dockerfile.dev` pour le développement qui inclura des outils comme `air` (pour le rechargement à chaud).

---

```yaml
# docker-compose.yml
#
# Ce fichier définit l'ensemble des services nécessaires pour faire fonctionner
# votre application Go avec Docker Compose. Il inclut des configurations
# pour la production et pour le développement.
#
# Version de la spécification Docker Compose. '3.8' ou plus récent est recommandé
# pour les fonctionnalités comme les profils de service et les healthchecks.
version: '3.8'

# --------------------------------------------------------------------------------------------------
# SERVICES
# Définit les différents conteneurs qui composent votre application.
# --------------------------------------------------------------------------------------------------
services:

  # Service principal de l'application Go
  # -------------------------------------
  app:
    # Build l'image Docker à partir du Dockerfile situé dans le répertoire courant.
    # Ceci est la configuration par défaut/production.
    build:
      context: .
      dockerfile: Dockerfile # Assurez-vous d'avoir un Dockerfile à la racine
    
    # Mappe les ports du conteneur aux ports de la machine hôte.
    # Ici, le port 8080 de l'application Go est accessible via le port 8080 de l'hôte.
    ports:
      - "8080:8080" # Exemple: Votre application Go écoute probablement sur le port 8080

    # Variables d'environnement pour l'application.
    # Il est recommandé d'utiliser un fichier .env (voir ci-dessous) pour les valeurs sensibles.
    environment:
      APP_ENV: production
      # Exemple de connexion à la base de données PostgreSQL:
      DATABASE_URL: postgres://user:password@db:5432/mydatabase?sslmode=disable
      # D'autres variables d'environnement spécifiques à votre application...

    # Définit les dépendances entre les services.
    # L'application ne démarrera que lorsque le service 'db' sera sain.
    depends_on:
      db:
        condition: service_healthy # Attend que le healthcheck de la base de données soit réussi

    # Politique de redémarrage : le conteneur redémarrera automatiquement
    # sauf s'il est arrêté explicitement.
    restart: unless-stopped
    
    # Les services peuvent être assignés à des profils. Ce service n'est pas dans un profil,
    # il sera donc démarré par défaut (ex: `docker-compose up`).

  # Service de développement pour l'application Go (avec rechargement à chaud)
  # --------------------------------------------------------------------------
  app-dev:
    # Ce service est désactivé par défaut et doit être lancé avec `--profile dev`.
    # Exemple: `docker-compose --profile dev up`
    profiles:
      - dev

    # Utilise un Dockerfile spécifique pour le développement.
    # Ce Dockerfile devrait inclure des outils comme 'air' pour le rechargement à chaud.
    build:
      context: .
      dockerfile: Dockerfile.dev # Créez un Dockerfile.dev adapté
    
    # Mappe les ports pour le développement, souvent les mêmes que la prod.
    ports:
      - "8080:8080"

    # Variables d'environnement spécifiques au développement.
    environment:
      APP_ENV: development
      DATABASE_URL: postgres://user:password@db:5432/mydatabase?sslmode=disable
      # Autres variables pour le dev...

    # Monte le répertoire courant de l'hôte dans le répertoire /app du conteneur.
    # Cela permet au conteneur de voir les modifications de code en temps réel.
    volumes:
      - .:/app
      # Cache les modules Go pour accélérer les reconstructions/démarrages.
      - go-mod-cache:/go/pkg/mod
    
    # Overrides le CMD/ENTRYPOINT du Dockerfile pour lancer 'air'.
    # 'air' surveillera les changements de fichiers Go et reconstruira/redémarrera l'application.
    command: air # Assurez-vous que 'air' est installé dans Dockerfile.dev

    depends_on:
      db:
        condition: service_healthy

    # Pas de restart unless-stopped pour le dev, car il est géré manuellement ou par 'air'.

  # Service de base de données PostgreSQL
  # ------------------------------------
  db:
    # Utilise une image PostgreSQL officielle. Choisissez une version spécifique (ex: 15-alpine pour une image plus légère).
    image: postgres:15-alpine

    # Variables d'environnement pour configurer la base de données.
    # Il est FORTEMENT recommandé d'utiliser un fichier .env (voir ci-dessous) pour ces valeurs en production.
    environment:
      POSTGRES_DB: mydatabase
      POSTGRES_USER: user
      POSTGRES_PASSWORD: password # REMPLACEZ PAR UN MOT DE PASSE SÉCURISÉ OU UTILISEZ UN .ENV
      PGDATA: /var/lib/postgresql/data/pgdata # Spécifie le répertoire de données

    # Mappe le volume persistant pour les données de la base de données.
    # Cela garantit que vos données ne sont pas perdues lorsque le conteneur est supprimé.
    volumes:
      - db-data:/var/lib/postgresql/data/pgdata # Mappe le volume nommé à l'emplacement des données PG
    
    # Expose le port PostgreSQL sur la machine hôte. Utile pour se connecter avec des clients SQL externes.
    ports:
      - "5432:5432"

    # Healthcheck pour s'assurer que la base de données est prête à accepter des connexions.
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U $$POSTGRES_USER -d $$POSTGRES_DB"] # $$ pour échapper $ dans le shell
      interval: 5s     # Vérifie toutes les 5 secondes
      timeout: 5s      # Temps maximum pour une vérification
      retries: 5       # Nombre de tentatives avant de déclarer le service "unhealthy"
      start_period: 10s # Période initiale pendant laquelle les échecs ne comptent pas pour les rétries

    restart: unless-stopped

# --------------------------------------------------------------------------------------------------
# VOLUMES
# Définit les volumes nommés pour la persistance des données.
# --------------------------------------------------------------------------------------------------
volumes:
  db-data: {} # Volume pour les données PostgreSQL
  go-mod-cache: {} # Volume pour cacher les modules Go (utile en développement)

# --------------------------------------------------------------------------------------------------
# INSTRUCTIONS D'UTILISATION
# --------------------------------------------------------------------------------------------------
# Pour lancer l'application en mode production (ou par défaut) :
#   docker-compose up -d
#
# Pour lancer l'application en mode développement (avec rechargement à chaud) :
#   docker-compose --profile dev up
#
# Pour arrêter tous les services :
#   docker-compose down
#
# Pour arrêter et supprimer les volumes (utile pour repartir à zéro) :
#   docker-compose down -v
#
# --------------------------------------------------------------------------------------------------
# CONSEILS SUPPLÉMENTAIRES
# --------------------------------------------------------------------------------------------------
# 1. Fichier .env :
#    Créez un fichier `.env` à la racine de votre projet (à côté de docker-compose.yml)
#    pour gérer vos variables d'environnement sensibles, comme les mots de passe.
#    Exemple de .env :
#    POSTGRES_PASSWORD=mon_super_mot_de_passe_secret
#    DATABASE_URL=postgres://user:${POSTGRES_PASSWORD}@db:5432/mydatabase?sslmode=disable
#    Docker Compose chargera automatiquement ce fichier.

# 2. Dockerfile.dev :
#    Un exemple simple de Dockerfile.dev pour le rechargement à chaud avec 'air' :
#    ```dockerfile
#    # Dockerfile.dev
#    FROM golang:1.22-alpine # Utilisez une version Go spécifique et Alpine pour la légèreté
#
#    WORKDIR /app
#
#    # Installe 'air' pour le rechargement à chaud
#    RUN go install github.com/cosmtrek/air@latest
#
#    # Copie les fichiers go.mod et go.sum pour gérer les dépendances en cache
#    COPY go.mod go.sum ./
#    RUN go mod download
#
#    # Le code source sera monté via un volume dans docker-compose.yml
#    # Le CMD sera surchargé par docker-compose.yml pour lancer 'air'
#    ```

# 3. .dockerignore :
#    Assurez-vous d'avoir un fichier `.dockerignore` pour exclure les fichiers inutiles
#    de votre contexte de build Docker, comme `node_modules`, `vendor/` (si non géré par Go modules),
#    `.git/`, `.env`, etc.
#    Exemple :
#    ```
#    # .dockerignore
#    .git/
#    .vscode/
#    .env
#    .DS_Store
#    *.swp
#    Dockerfile.dev
#    vendor/ # Si vous utilisez Go modules, cela est souvent inclus dans le build
#    ```
```