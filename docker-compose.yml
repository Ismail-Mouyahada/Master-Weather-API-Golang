Absolument ! Voici un exemple de configuration `docker-compose.yml` pour un projet Go, incluant une base pour la production et une configuration d'override pour le développement.

Pour que cela fonctionne, vous aurez besoin d'un `Dockerfile` pour votre application Go. Je vais en inclure un exemple simple multi-stage.

---

### Structure du Projet (Exemple)

```
.
├── docker-compose.yml
├── docker-compose.override.yml  # Pour le développement
├── Dockerfile                  # Pour l'application Go
├── .air.toml                   # Pour le rechargement à chaud en dev (optionnel)
├── main.go                     # Votre application Go
├── go.mod
└── go.sum
```

---

### 1. `Dockerfile` (Pour l'application Go)

Ce `Dockerfile` utilise une construction multi-étape pour créer un binaire Go léger.

```dockerfile
# --- Étape de Construction (Builder Stage) ---
# Utilise une image Go complète pour la compilation.
FROM golang:1.22-alpine AS builder

# Définit le répertoire de travail dans le conteneur.
WORKDIR /app

# Copie les fichiers de dépendances Go et les télécharge.
# Ceci permet de mettre en cache les modules et d'accélérer les builds si seul le code change.
COPY go.mod go.sum ./
RUN go mod download

# Copie le reste du code source de l'application.
COPY . .

# Construit l'application Go.
# CGO_ENABLED=0: Désactive la liaison CGO, rendant le binaire complètement statique et plus portable.
# GOOS=linux: S'assure que le binaire est compilé pour Linux.
# -a -installsuffix cgo: Force la reconstruction de tous les paquets et ajoute un suffixe.
# -o main: Nomme le binaire de sortie 'main'.
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# --- Étape d'Exécution (Runtime Stage) ---
# Utilise une image Alpine minimale pour l'exécution, ce qui réduit considérablement la taille du conteneur final.
FROM alpine:latest

# Définit le répertoire de travail.
WORKDIR /app

# Copie le binaire compilé depuis l'étape de construction.
COPY --from=builder /app/main .

# Expose le port sur lequel l'application Go écoute.
# (Assurez-vous que votre application Go écoute bien sur ce port, ex: ":8080")
EXPOSE 8080

# Commande par défaut pour exécuter l'application.
CMD ["./main"]
```

---

### 2. `docker-compose.yml` (Configuration de Base / Production)

Ce fichier définit les services essentiels et leurs configurations pour un environnement de production.

```yaml
# Version de Docker Compose utilisée.
version: '3.8'

# Définition des services de l'application.
services:
  # Service pour l'application Go
  go-app:
    build:
      context: .             # Le contexte de build est le répertoire actuel.
      dockerfile: Dockerfile # Utilise le Dockerfile situé à la racine.
    ports:
      # Mappe le port 8080 du conteneur au port 8080 de l'hôte.
      # Pour la production, vous pourriez envisager un proxy inverse (nginx/Caddy) devant Docker.
      - "8080:8080"
    environment:
      # Variables d'environnement pour l'application Go.
      # Celles-ci doivent être lues par votre application Go.
      APP_ENV: production
      PORT: 8080
      # Configuration de la base de données PostgreSQL
      DB_HOST: db            # Le nom du service Docker Compose pour la base de données.
      DB_PORT: 5432
      DB_USER: app_user
      DB_PASSWORD: supersecretpassword
      DB_NAME: my_go_app_db
      # Configuration Redis (si utilisée)
      REDIS_HOST: redis
      REDIS_PORT: 6379
    depends_on:
      # S'assure que les services `db` et `redis` sont démarrés avant `go-app`.
      # Note: cela ne garantit pas que les services sont "prêts" à accepter des connexions.
      # Votre application Go doit implémenter une logique de reconnexion.
      - db
      - redis # Décommenter si votre application utilise Redis
    restart: always # Redémarre le conteneur s'il échoue.

  # Service pour la base de données PostgreSQL
  db:
    image: postgres:16-alpine # Utilise l'image PostgreSQL 16 (version alpine pour une taille réduite).
    environment:
      POSTGRES_DB: my_go_app_db
      POSTGRES_USER: app_user
      POSTGRES_PASSWORD: supersecretpassword
    volumes:
      # Monte un volume nommé pour persister les données de la base de données.
      # Ceci est crucial pour ne pas perdre vos données lorsque le conteneur est recréé.
      - db_data:/var/lib/postgresql/data
    restart: always

  # Service pour Redis (système de cache, file d'attente, etc.)
  redis:
    image: redis:7-alpine # Utilise l'image Redis 7 (version alpine pour une taille réduite).
    volumes:
      # Monte un volume nommé pour persister les données de Redis (si AOF ou RDB sont activés).
      - redis_data:/data
    restart: always

# Définition des volumes nommés.
# Docker gérera la création et la persistance de ces volumes.
volumes:
  db_data: {}
  redis_data: {} # Décommenter si vous utilisez Redis
```

---

### 3. `docker-compose.override.yml` (Configuration pour le Développement)

Ce fichier est utilisé en conjonction avec `docker-compose.yml` pour ajouter ou modifier des configurations spécifiques au développement.
Il est automatiquement pris en compte par `docker compose up` si présent dans le même répertoire.

```yaml
# Version de Docker Compose. Doit correspondre à celle du fichier principal.
version: '3.8'

services:
  go-app:
    # Pour le développement, nous voulons monter le code source de l'hôte
    # afin que les changements soient reflétés immédiatement sans reconstruire l'image.
    volumes:
      - .:/app # Monte le répertoire courant de l'hôte dans /app du conteneur.
      # Vous pourriez vouloir exclure le répertoire des modules Go si vous le gérez différemment
      # - /app/vendor

    # Remplace la commande par défaut du Dockerfile pour le développement.
    # Option 1: Utiliser 'go run' pour exécuter l'application directement.
    # Cela recompile à chaque exécution, mais est simple.
    # command: go run main.go

    # Option 2: Utiliser un outil de rechargement à chaud comme 'Air'.
    # Cela nécessite que 'Air' soit installé dans le Dockerfile ou dans le conteneur.
    # Voir la section ".air.toml" ci-dessous.
    command: air -c .air.toml # Assurez-vous que 'air' est installé dans l'image de dev.

    environment:
      APP_ENV: development
      # Vous pouvez ajouter d'autres variables spécifiques au développement ici (ex: DEBUG=true)
      DB_HOST: db
      DB_PORT: 5432
      DB_USER: app_user_dev # Utiliser des identifiants différents pour le dev si nécessaire
      DB_PASSWORD: devpassword
      DB_NAME: my_go_app_db_dev
      REDIS_HOST: redis
      REDIS_PORT: 6379

  db:
    ports:
      # Expose le port 5432 de la base de données sur l'hôte.
      # Utile pour se connecter avec des outils externes (ex: DBeaver, pgAdmin) pendant le développement.
      - "5432:5432"
    environment:
      # On peut utiliser une base de données différente pour le développement.
      POSTGRES_DB: my_go_app_db_dev
      POSTGRES_USER: app_user_dev
      POSTGRES_PASSWORD: devpassword

  redis:
    ports:
      # Expose le port 6379 de Redis sur l'hôte pour faciliter le débogage.
      - "6379:6379"
```

---

### 4. `.air.toml` (Pour le rechargement à chaud en développement - Optionnel)

Pour utiliser le rechargement à chaud avec `air`, vous devez l'installer dans votre conteneur de développement. La manière la plus simple est de l'ajouter à votre `Dockerfile` *avant* la construction pour le stage `builder` ou même un stage dédié pour le développement.

Modifiez votre `Dockerfile` pour inclure `air` si vous choisissez cette option (ajoutez après `go mod download`):

```dockerfile
# ... (dans le stage builder) ...
COPY go.mod go.sum ./
RUN go mod download

# Installer Air pour le développement
RUN go install github.com/cosmtrek/air@latest
# ... (le reste du Dockerfile) ...
```

Puis, créez un fichier `.air.toml` à la racine de votre projet :

```toml
root = "."
tmp_dir = "tmp"

[build]
# Commande de construction pour Go.
cmd = "go build -o ./tmp/main ."
# Répertoires à surveiller pour les changements.
include_dir = ["."]
# Répertoires à ignorer pour les changements.
exclude_dir = ["tmp", "vendor", "node_modules"]
# Extensions de fichiers à surveiller.
include_ext = ["go", "tpl", "tmpl", "html", "yaml", "yml", "json"]

[run]
# Commande d'exécution après une construction réussie.
cmd = "./tmp/main"
# Fichiers à ignorer pour le redémarrage.
exclude_file = []

[log]
# Niveau de log.
time_format = "15:04:05"

[color]
app = ""
build = "yellow"
main = "magenta"
runner = "green"
watcher = "cyan"

[misc]
# Effacer le terminal avant chaque exécution.
clear_terminal = true
```

---

### Instructions d'Utilisation

1.  **Créez les fichiers** : Copiez le `Dockerfile`, `docker-compose.yml`, `docker-compose.override.yml` et `.air.toml` (si utilisé) dans le répertoire racine de votre projet Go.
2.  **Adaptez votre code Go** :
    *   Votre application Go doit lire les variables d'environnement (`DB_HOST`, `DB_USER`, `PORT`, etc.) pour se connecter aux services.
    *   Assurez-vous qu'elle écoute sur le port `8080` (ou celui que vous avez configuré).
3.  **Démarrer en Développement** :
    ```bash
    docker compose up --build # ou `docker-compose up --build` si vous n'avez pas la v2
    ```
    Cela va construire les images (si nécessaire) et démarrer tous les services. Grâce à `docker-compose.override.yml`, votre code Go local sera monté dans le conteneur, et si vous utilisez `air`, les changements déclencheront un redémarrage automatique.
4.  **Démarrer en Production (sans override)** :
    ```bash
    # Assurez-vous que docker-compose.override.yml n'est pas présent ou renommé.
    # Ou spécifiez explicitement le fichier principal :
    docker compose -f docker-compose.yml up --build -d
    ```
    L'option `-d` détachera les conteneurs du terminal.
5.  **Arrêter les services** :
    ```bash
    docker compose down
    ```
    Ceci arrêtera et supprimera les conteneurs et les réseaux par défaut, mais *pas les volumes nommés* (`db_data`, `redis_data`), préservant ainsi vos données.
6.  **Arrêter et supprimer tout (y compris les volumes)** :
    ```bash
    docker compose down --volumes
    ```
    Utilisez cette commande avec prudence, car elle supprimera toutes les données persistantes de votre base de données et Redis.

---

Cette configuration vous offre une base solide pour développer et déployer votre application Go avec Docker Compose, en tenant compte des besoins spécifiques du développement (rapidité d'itération) et de la production (stabilité, persistance, légèreté).